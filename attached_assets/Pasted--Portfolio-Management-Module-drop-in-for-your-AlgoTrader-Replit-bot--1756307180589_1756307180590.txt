"""
Portfolio Management Module — drop-in for your AlgoTrader/Replit bot
====================================================================

Purpose
-------
Add robust **portfolio tracking + analytics** to your existing Python trading repo (e.g., your `AlgoTrader` on GitHub or the Replit bot we built). This module:

- Records fills (FIFO cost basis)
- Tracks positions, cash, equity, and P&L (realized & unrealized)
- Marks-to-market with live prices
- Computes performance metrics (Sharpe, Sortino, max drawdown, win rate, profit factor, expectancy, etc.)
- Exposes a tiny optional FastAPI for a lightweight dashboard (`/metrics`, `/positions`, `/trades`, `/equity`)
- Persists everything in **SQLite** (`portfolio.db` by default)

How to integrate (quick)
------------------------
1) Save this file as `portfolio_management.py` in your repo.
2) In your trade execution code, call **`pm.record_fill(...)`** when an order is filled (or immediately after submission in paper mode), and **`pm.mark_to_market({symbol: price})`** each polling loop.
3) (Optional) launch the API: `uvicorn portfolio_management:app --reload --port 8000`.

Environment vars (optional)
---------------------------
- `PORTFOLIO_DB` — path for SQLite file (default `portfolio.db`)
- `TS_FREQ` — equity sampling frequency (default `'1min'` if you call `mark_to_market` that often)

Notes
-----
- For **exact** fills with Alpaca, register the streaming `TradeUpdates` and route `fill` events into `pm.record_fill(...)`. A stub is included below.
- Educational use only.
"""
from __future__ import annotations
import os
import math
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Dict, Iterable, List, Optional, Tuple

import numpy as np
import pandas as pd

# --------------------------- Persistence ---------------------------
_DB_PATH = os.getenv("PORTFOLIO_DB", "portfolio.db")

SCHEMA_SQL = """
PRAGMA journal_mode=WAL;
CREATE TABLE IF NOT EXISTS cash_ledger (
  ts TEXT NOT NULL,
  delta REAL NOT NULL,
  reason TEXT,
  PRIMARY KEY (ts)
);

CREATE TABLE IF NOT EXISTS positions (
  symbol TEXT PRIMARY KEY,
  qty REAL NOT NULL,
  avg_price REAL NOT NULL,
  last_price REAL,
  updated_at TEXT
);

CREATE TABLE IF NOT EXISTS lots (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  symbol TEXT NOT NULL,
  qty_remaining REAL NOT NULL,
  cost_price REAL NOT NULL,
  created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS trades (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  ts TEXT NOT NULL,
  symbol TEXT NOT NULL,
  side TEXT NOT NULL CHECK(side IN ('BUY','SELL')),
  qty REAL NOT NULL,
  price REAL NOT NULL,
  fees REAL DEFAULT 0,
  realized_pnl REAL DEFAULT 0,
  tag TEXT
);

CREATE INDEX IF NOT EXISTS idx_trades_symbol_ts ON trades(symbol, ts);

CREATE TABLE IF NOT EXISTS equity_curve (
  ts TEXT PRIMARY KEY,
  equity REAL NOT NULL
);
"""


def _connect() -> sqlite3.Connection:
    con = sqlite3.connect(_DB_PATH, check_same_thread=False)
    con.row_factory = sqlite3.Row
    return con


# --------------------------- Core data ---------------------------
@dataclass
class Fill:
    symbol: str
    side: str  # 'BUY' or 'SELL'
    qty: float
    price: float
    ts: Optional[datetime] = None
    fees: float = 0.0
    tag: Optional[str] = None


class PortfolioManager:
    def __init__(self, starting_cash: float = 0.0):
        self.con = _connect()
        with self.con:
            self.con.executescript(SCHEMA_SQL)
        if starting_cash:
            self._cash_add(starting_cash, reason="starting_cash")

    # ---- Cash ----
    def _cash_add(self, amount: float, reason: str):
        ts = datetime.now(timezone.utc).isoformat()
        with self.con:
            self.con.execute(
                "INSERT INTO cash_ledger (ts, delta, reason) VALUES (?,?,?)",
                (ts, float(amount), reason),
            )

    def cash_balance(self) -> float:
        cur = self.con.execute("SELECT COALESCE(SUM(delta),0) AS bal FROM cash_ledger")
        return float(cur.fetchone()["bal"]) or 0.0

    # ---- Positions / Lots ----
    def _get_position(self, symbol: str) -> Optional[sqlite3.Row]:
        cur = self.con.execute("SELECT * FROM positions WHERE symbol=?", (symbol,))
        return cur.fetchone()

    def _upsert_position(self, symbol: str, qty: float, avg_price: float, last_price: Optional[float]):
        ts = datetime.now(timezone.utc).isoformat()
        with self.con:
            self.con.execute(
                """
                INSERT INTO positions(symbol, qty, avg_price, last_price, updated_at)
                VALUES (?,?,?,?,?)
                ON CONFLICT(symbol) DO UPDATE SET
                  qty=excluded.qty,
                  avg_price=excluded.avg_price,
                  last_price=excluded.last_price,
                  updated_at=excluded.updated_at
                """,
                (symbol, qty, avg_price, last_price, ts),
            )

    def _add_lot(self, symbol: str, qty: float, price: float):
        ts = datetime.now(timezone.utc).isoformat()
        with self.con:
            self.con.execute(
                "INSERT INTO lots(symbol, qty_remaining, cost_price, created_at) VALUES (?,?,?,?)",
                (symbol, qty, price, ts),
            )

    def _consume_fifo(self, symbol: str, qty: float) -> Tuple[float, List[Tuple[float, float]]]:
        """Consume lots FIFO; return (avg_cost, breakdown[(qty, cost_price), ...])."""
        cur = self.con.execute(
            "SELECT id, qty_remaining, cost_price FROM lots WHERE symbol=? AND qty_remaining>0 ORDER BY id ASC",
            (symbol,),
        )
        rows = cur.fetchall()
        remaining = qty
        cost_total = 0.0
        used: List[Tuple[float, float]] = []
        for r in rows:
            if remaining <= 0:
                break
            take = min(remaining, r["qty_remaining"]) 
            remaining -= take
            cost_total += take * float(r["cost_price"]) 
            used.append((take, float(r["cost_price"])) )
            new_left = float(r["qty_remaining"]) - take
            with self.con:
                self.con.execute("UPDATE lots SET qty_remaining=? WHERE id=?", (new_left, r["id"]))
        if remaining > 1e-9:
            raise ValueError(f"Not enough inventory to sell {qty} {symbol}")
        qty_sum = sum(q for q, _ in used)
        avg_cost = cost_total / max(qty_sum, 1e-9)
        return avg_cost, used

    # ---- Recording fills ----
    def record_fill(self, fill: Fill) -> float:
        """Record a BUY/SELL fill; update lots, positions, cash; return realized PnL for this fill."""
        ts = (fill.ts or datetime.now(timezone.utc)).isoformat()
        side = fill.side.upper()
        qty = float(fill.qty)
        price = float(fill.price)
        fees = float(fill.fees or 0.0)

        pos = self._get_position(fill.symbol)
        cur_qty = float(pos["qty"]) if pos else 0.0
        cur_avg = float(pos["avg_price"]) if pos else 0.0

        realized = 0.0
        cash_delta = 0.0

        if side == "BUY":
            # Add lot, update position avg
            self._add_lot(fill.symbol, qty, price)
            new_qty = cur_qty + qty
            new_avg = (cur_avg * cur_qty + price * qty) / max(new_qty, 1e-9)
            self._upsert_position(fill.symbol, new_qty, new_avg, last_price=price)
            cash_delta = -(price * qty + fees)
        elif side == "SELL":
            avg_cost, breakdown = self._consume_fifo(fill.symbol, qty)
            realized = (price - avg_cost) * qty - fees
            new_qty = cur_qty - qty
            if new_qty < -1e-9:
                raise ValueError(f"Sell exceeds position for {fill.symbol}: have {cur_qty}, sell {qty}")
            new_avg = cur_avg if new_qty > 1e-9 else 0.0
            self._upsert_position(fill.symbol, new_qty, new_avg, last_price=price)
            cash_delta = +(price * qty - fees)
        else:
            raise ValueError("side must be BUY or SELL")

        with self.con:
            self.con.execute(
                "INSERT INTO trades(ts, symbol, side, qty, price, fees, realized_pnl, tag) VALUES (?,?,?,?,?,?,?,?)",
                (ts, fill.symbol, side, qty, price, fees, realized, fill.tag),
            )
        if abs(cash_delta) > 0:
            self._cash_add(cash_delta, reason=f"{side} {fill.symbol}")
        return realized

    # ---- Mark-to-market / Equity ----
    def mark_to_market(self, prices: Dict[str, float], record_equity: bool = True):
        # Update last prices and compute unrealized
        with self.con:
            for sym, px in prices.items():
                pos = self._get_position(sym)
                if pos:
                    self.con.execute(
                        "UPDATE positions SET last_price=?, updated_at=? WHERE symbol=?",
                        (float(px), datetime.now(timezone.utc).isoformat(), sym),
                    )
        # compute equity
        positions = self.positions()
        mtm = sum(p["qty"] * (p["last_price"] or p["avg_price"]) for p in positions)
        eq = self.cash_balance() + mtm
        if record_equity:
            with self.con:
                self.con.execute(
                    "INSERT OR REPLACE INTO equity_curve(ts, equity) VALUES (?,?)",
                    (datetime.now(timezone.utc).isoformat(), float(eq)),
                )
        return eq

    # ---- Queries ----
    def positions(self) -> List[sqlite3.Row]:
        cur = self.con.execute("SELECT * FROM positions WHERE ABS(qty) > 1e-9 ORDER BY symbol")
        return cur.fetchall()

    def trades(self, limit: Optional[int] = 200) -> List[sqlite3.Row]:
        sql = "SELECT * FROM trades ORDER BY ts DESC"
        if limit:
            sql += f" LIMIT {int(limit)}"
        return self.con.execute(sql).fetchall()

    def equity_curve(self) -> pd.DataFrame:
        df = pd.read_sql_query("SELECT ts, equity FROM equity_curve ORDER BY ts ASC", self.con, parse_dates=["ts"])
        return df

    # ---- Metrics ----
    def metrics(self, assume_trading_days: int = 252) -> Dict[str, float]:
        # Equity-based metrics
        df = self.equity_curve()
        out: Dict[str, float] = {}
        if len(df) >= 2:
            eq0, eqN = float(df["equity"].iloc[0]), float(df["equity"].iloc[-1])
            out["total_return"] = (eqN - eq0) / max(eq0, 1e-9)
            # Convert to daily returns (resample to day boundary)
            dfd = df.set_index("ts").resample("1D").last().dropna()
            rets = dfd["equity"].pct_change().dropna()
            if len(rets) > 1:
                out["sharpe"] = (rets.mean() / (rets.std() + 1e-12)) * math.sqrt(assume_trading_days)
                downside = rets[rets < 0]
                out["sortino"] = (rets.mean() / (downside.std() + 1e-12)) * math.sqrt(assume_trading_days)
                # Max drawdown
                roll_max = dfd["equity"].cummax()
                dd = dfd["equity"] / roll_max - 1.0
                out["max_drawdown"] = float(dd.min())
        # Trade-based metrics
        tr = pd.read_sql_query("SELECT realized_pnl FROM trades WHERE side='SELL' ORDER BY ts ASC", self.con)
        if not tr.empty:
            pnl = tr["realized_pnl"].astype(float)
            wins = pnl[pnl > 0]
            losses = pnl[pnl < 0]
            out["win_rate"] = float((len(wins) / max(len(pnl), 1)))
            out["avg_win"] = float(wins.mean()) if len(wins) else 0.0
            out["avg_loss"] = float(losses.mean()) if len(losses) else 0.0
            gross_profit = float(wins.sum()) if len(wins) else 0.0
            gross_loss = float(-losses.sum()) if len(losses) else 0.0
            out["profit_factor"] = float(gross_profit / max(gross_loss, 1e-9)) if gross_loss else float("inf") if gross_profit>0 else 0.0
            out["expectancy"] = float(pnl.mean()) if len(pnl) else 0.0
        return out


# --------------------------- Optional FastAPI ---------------------------
try:
    from fastapi import FastAPI
    from fastapi.responses import JSONResponse
    app = FastAPI(title="Portfolio API")
    _PM = PortfolioManager()

    @app.get("/metrics")
    def api_metrics():
        return JSONResponse(_PM.metrics())

    @app.get("/positions")
    def api_positions():
        rows = [dict(r) for r in _PM.positions()]
        return JSONResponse(rows)

    @app.get("/trades")
    def api_trades(limit: int = 200):
        rows = [dict(r) for r in _PM.trades(limit=limit)]
        return JSONResponse(rows)

    @app.get("/equity")
    def api_equity():
        return JSONResponse(PortfolioManager().equity_curve().to_dict(orient="list"))
except Exception:
    app = None


# --------------------------- Alpaca streaming stub ---------------------------
"""
If you use Alpaca, you can stream fills and feed them to PortfolioManager in *real time*:

from alpaca.trading.stream import TradingStream
from alpaca.trading.client import TradingClient
from alpaca.trading.enums import OrderSide

pm = PortfolioManager(starting_cash=100000)
trading_client = TradingClient(API_KEY, SECRET_KEY, paper=True)

stream = TradingStream(API_KEY, SECRET_KEY, paper=True)

@stream.on("trade_updates")
async def handle_trade_updates(data):
    # data.event can be 'fill', 'partial_fill', 'canceled', etc.
    ev = data.event
    o = data.order
    if ev == 'fill':
        side = 'BUY' if o.side == OrderSide.BUY else 'SELL'
        pm.record_fill(Fill(
            symbol=o.symbol,
            side=side,
            qty=float(o.filled_qty),
            price=float(o.filled_avg_price or o.limit_price or o.stop_price),
            fees=0.0,
            tag='alpaca'
        ))

stream.run()
"""


# --------------------------- Quick demo ---------------------------
if __name__ == "__main__":
    pm = PortfolioManager(starting_cash=100000)
    # Simulate two fills and MTM
    pm.record_fill(Fill(symbol="AAPL", side="BUY", qty=10, price=190.00))
    pm.mark_to_market({"AAPL": 191.0})
    pm.record_fill(Fill(symbol="AAPL", side="SELL", qty=5, price=192.50))
    eq = pm.mark_to_market({"AAPL": 193.0})
    print("Equity:", eq)
    print("Metrics:", pm.metrics())
